<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>.NET Microservices mit RabbitMQ Advanced</title>

		<meta name="description" content=".NET Microservices mit RabbitMQ (Advanced)">
    	<meta name="author" content="Frank Pommerening">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
				<h1>.NET Microservices mit RabbitMQ (Advanced)</h1>
                <h2>Spartakiade 2017</h2>
				<img src="images/logo_spartakiade.png" style="border:0px;width:200px"/>
            	</section>
				<section>
				  <section>
                    <h2>Frank Pommerening</h2>
                    <img src="images/fp.jpg" style="border:0px;width:175px">
                    <ul>
                        <li>Senior - Softwareentwickler</li>
                        <li>Consultant</li>
                        <li>Softwarearchitekt</li>
                    </ul>
                    <br />
                    <br />
                    <a href="mailto:frank@pommerening-online.de">frank@pommerening-online.de</a>
                </section>
				 <section data-background="images/axp.svg">
				
                    AXP Consulting GmbH & Co. KG in Leipzig<br/>
                    Gründung: Mai 2012 <br />
                    Anzahl Mitarbeiter:	8 feste <br/>
                    Branchenfokus: Energiebranche <br/>
					<br/>
					<br/>
                    <ul>

                    <li>Consulting (fachlich & IT)
<ul>
    <li>Requirements Engineering / Projektmanagement </li>
    <li>IT-Fachprozess-Analyse / Dokumentation</li>
</ul>
                    </li>
                    <li>Software-Entwicklung
                        <ul>
                            <li>Microservices, SOA, REST, OOA und OOD</li>
                             <li>Microsoft Technologien z.B. .NET (C#), WPF, WCF</li>
<li>Datenbanken (MS SQL Server / Oracle  / MongoDB)
                            </ul>
                        </li>
                    </ul>
                </section>
            </section>
			<section>
				<section>
                    <h2>Vorbereitung</h2>
                    <h3>Startup-App</h3>
                    Info: <a href="https://goo.gl/x3jJbr">https://goo.gl/x3jJbr</a>
                    <br />
                    <br />
                    <h3>MyGet-Feeds</h3>
                    EasyNetQ<br/> <a href="https://www.myget.org/F/easynetq-unstable/api/v3/index.json"> https://www.myget.org/F/easynetq-unstable/api/v3/index.json</a>
                    <br />
                    ImageProcessor: <a href="https://www.myget.org/F/imageprocessor/api/v3/index.json"> https://www.myget.org/F/imageprocessor/api/v3/index.json</a>
                </section>
			</section>
            <section>
                <section>
                    <h2>EasyNetQ </h2>
                    <h3 class="fragment">short revision ?!</h3>
                </section>
                <section>
                    <h2>EasyNetQ</h2>
                    <img src="images/logo_easynetq.png" style="border:0px" alt="Logo EasyNetQ">
                    <ul>
                        <li>Einfach</li>
                        <li>Open Source</li>
                        <li>Modular</li>
                    <br />
                    </ul>
                    </br>
                    </br>
                    Nuget: <a href="https://www.nuget.org/packages/EasyNetQ/" target="_blank">EasyNetQ</a></br>
                    Github: <a href="https://github.com/EasyNetQ/EasyNetQ" target="_blank">https://github.com/EasyNetQ/EasyNetQ</a>
                </section>
            
            <section>
                    <h3>Vorteile</h3>
                    <ul>
                        <li>Messaging Pattern, z.B. Publish/Subscribe </li>
                        <li>Routing Strategien</li>
                        <li>Serialisierung / Deserialisierung als JSON (lesbar)</li>
                        <li>Handling von Thread für Konsumenten</li>
                        <li>Subscriber Reconnect</li>
                        <li>QoS / publisher confirm</li>
                        <li>Fehlerbehandlung</li>
                    </ul>
                </section>
                 <section>
                    <h3>API Design</h3>
                    <img src="images/EasyNetQ.svg" alt="API EasyNETQ" style="border:0px">
                </section>
                <section>
                    <h3>Verbindungsaufbau</h3>
                    <pre><code class="cs">
using System;
using EasyNetQ;

namepace FP.MsRmq.Connecting
{
    public class Programm
    {
        public static void Main(string[] args)
        {
            var myBus = RabbitHutch.CreateBus("host=myRabbitMQ");
        }
    }
}
</code>
                    </pre>
                </section>
                <section>
                    <h3>Verbindungsoptionen</h3>
                    <table>
                        <thead>
                            <tr>
                                <th>Option</th>
                                <th>Standardwert</th>
                                <th>Bemerkung</th>
                        </thead>
						<tbody>
							<tr>
								<td>host</td>
                                <td>5672</td>
                                <td>DNS-Name/IP[:Port]</td>
							</tr>
							<tr>
								<td>username</td>
                                <td>guest</td>
                                <td></td>								
							</tr>
							<tr>
								<td>passwort</td>
								<td>guest</td>
                                <td></td>
							</tr>
                            <tr>
                                <td>prefetchcount</td>
                                <td>50</td>
                                <td>Anzahl der Nachrichten, die gleichzeitig abgerufen werden</td>
                            </tr>
                            <tr>
                                <td>timeout</td>
                                <td>10</td>
                                <td>timeout in Sekunden</td>
                            </tr>
						</tbody>
					</table>
                </section>
                <section>
                    <h3>Publish / Subscribe</h3>
                        Sendet eine Nachricht an beliebig viele Empfänger<br/><br/>
                        Wenn kein Empfänger definiert wurde, geht Nachricht verloren (keine Speicherung / Verarbeitung)<br /><br />
                        Zieltypen der Bestellung müssen übereinstimmen <br /><br />
                        Polymorphy ist möglich
                    </ul>
                </section>
                <section>
                     Subscribe
                        <pre><code class="cs">
 myBus.Subscribe&lt;MyClass&gt;("MySub", 
        msg => DoSomething(msg));
 myBus.SubscribeAsync&lt;MyClass&gt;("MySubAsync",
        msg => DoSomethingAsync(msg));
     </code>
                    </pre>
                    Publish
                        <pre><code class="cs">
var msg = new MyClass{};                            
myBus.Publish(msg);
myBus.PublishAsync(msg);
     </code>
                    </pre>
                </section>
                <section>
                    <h3>Topic Based Routing</h3>
                       Sonderform des Publish / Subscribe<br/><br/>
                       Neben dem Zieltyp muss auch das Thema (Topic) passen<br/><br/>
                       Im Thema sind Platzhalter möglich
                    
                </section>
                   <section>
                     Subscribe
                        <pre><code class="cs">
 myBus.Subscribe&lt;MyClass&gt;("MyTopicSub", 
        msg => DoSomething(msg), x => x.WithTopic("MyTopic"));
     </code>
                    </pre>
                    Publish
                        <pre><code class="cs">
var msg = new MyClass{};                            
myBus.Publish(msg, "MyTopic");
     </code>
                    </pre>
                </section>
                <section>
                    <h3>Request / Response (RPC)</h3>
                    Sendet eine Nachricht und erwartet eine Antwort<br /><br />
                    Matching über Typen der Anfrage und der Antwort<br/><br />
                    Exception, wenn Antwort nicht innerhalb Timeout 
                </section>
                <section>
                    Response
                        <pre><code class="cs">
myBus.Respond&lt;MyClass1,MyClass2&gt;(DoSometingWithResult);
myBus.RespondAsync&lt;MyClass1,MyClass2&gt;(DoSometingAsyncWithResult);
                    </code></pre>
                    Request
                        <pre><code class="cs">
var req = new MyClass1{};                            
var result = myBus.Request&lt;MyClass1,MyClass2&gt;(req);
var result = await myBus.RequestAsync&lt;MyClass1,MyClass2&gt;(req);
                    </code></pre>
                </section>  
                <section>
                    <h3>Send / Receive (Command Pipelines)</h3>
                    Command Pipelines<br /><br />
                    Queue enthält Nachrichten verschiedener Typen<br /> <br />
                    Bestellung wird auf den Nachrichtentyp eingegrenzt<br /> <br />
                    Nicht zustellbare Nachrichten werden in Error-Queue übertragen
                </section>
                 <section>
                    Receive
                        <pre><code class="cs">
myBus.Receive("MyMessageQueue", x => x
    .Add&lt;MyClassA&gt;(DoSomethingWithA)
    .Add&lt;MyClassB&gt;(DoSomethingWithB);
                    </code></pre>
                    Request
                        <pre><code class="cs">
myBus.Send("MyMessageQueue", new MyClassA {});
myBus.Send("MyMessageQueue", new MyClassB {});

                    </code></pre>
                </section>
            </section>
            <section>
                <section>
                    <h2>RabbitMQ im Cluster</h2>
                    <img src="images/logo_rabbitmq.png" style="border:0px" alt="Logo of Rabbit MQ"/>
                </section>
                <section>
                    <h3>Voraussetzungen</h3>
                    Damit die verschienden Nodes verknüpft werden können, müssen sie das gleich ERLANG COOKIE besitzen.
                </section>
                <section>
                    <h3>Beispiel mit Docker</h3>
                    Hinweis: Sicherheit und eventuelle Firewallanpassung werden außer Acht gelassen.
                </section>
                <section>
                    Netzwerk definieren
                       <pre>
                            <code data-trim contenteditable>
$ docker network create rmqcluster
                            </code>
                        </pre>
                      Start Node1 (Master)
                     <pre>
                            <code data-trim contenteditable>
$ docker run -d --hostname rmqNode1 --name rmqNode1 --network=rmqcluster 
    -p 5672:5672 -p 15672:15672 -e RABBITMQ_ERLANG_COOKIE='strenggeheim'
    rabbitmq:3-management
                            </code>
                        </pre>
                    Start Node2 (Node mit Persistenz)
                    <pre>
                            <code data-trim contenteditable>
$ docker run -d --hostname rmqNode2 --name rmqNode2 --network=rmqcluster 
    -p 5673:5672 -p 15673:15672 -e RABBITMQ_ERLANG_COOKIE='strenggeheim' 
    rabbitmq:3-management
                            </code>
                        </pre>
                </section>
                <section>
                    Start Node3 (RAM Node)
                    <pre>
                            <code data-trim contenteditable>
$ docker run -d --hostname rmqNode3 --name rmqNode3 --network=rmqcluster 
    -p 5674:5672 -p 15674:15672 -e RABBITMQ_ERLANG_COOKIE='strenggeheim' 
    rabbitmq:3-management
                            </code>
                        </pre>
                    Container zur Konfiguration
                     <pre>
                        <code data-trim contenteditable>
$ docker run -it --rm --network=rmqcluster 
	-e RABBITMQ_ERLANG_COOKIE='strenggeheim' rabbitmq:3
    /bin/bash
                            </code>
                        </pre>
                </section>
                <section>
                        Hinzufügen Node 2
                        <pre>
                        <code data-trim contenteditable>
rabbitmqctl -n rabbit@rmqNode2 stop_app
rabbitmqctl -n rabbit@rmqNode2 join_cluster rabbit@rmqNode1
rabbitmqctl -n rabbit@rmqNode2 start_app
                              </code>
                        </pre>
                        Hinzufügen Node 3
                        <pre>
                        <code data-trim contenteditable>
rabbitmqctl -n rabbit@rmqNode3 stop_app
rabbitmqctl -n rabbit@rmqNode3 join_cluster --ram rabbit@rmqNode1
rabbitmqctl -n rabbit@rmqNode3 start_app
                              </code>
                        </pre>
                </section>
                <section>
                    <h3>Aktivierung der Hochverfügbarkeit</h3>
                    <a href="https://www.rabbitmq.com/ha.html" target="_blank">Info</a>
                        <pre>
                        <code data-trim contenteditable>
                         rabbitmqctl -n rabbit@rmqNode1 set_policy ha-all "" '{"ha-mode":"all"}' 
                              </code>
                        </pre>
                </section>
            </section>
            <section>
                <section>
                    <h2>EasyNetQ im Cluster</h2>
                </section>
                <section>
                    
                    <h3>Cluster mit TCP-Loadbalancer</h3>
                    Loadbalancer entscheidet über Verteilung und ist für den Client transparent.
                     <pre><code class="cs">var myBus = RabbitHutch.CreateBus("host=IP-LoadBalancer");</code></pre>
                    <h3>Cluster mit re-try loop</h3>
                    EasyNetQ versucht nach einem Verbindungsproblem den nächsten Host. Ist kein Host verfügbar, werden alle 5 Sekunde alle Host geprüft.
                     <pre><code class="cs">var myBus = RabbitHutch.CreateBus("host=host1,host2,host3");</code></pre>
                </section>
                 <section>
                     <h2>Cluster-Capture</h2>
                        <img src="images/ClusterSample.svg" alt="Cluster sample" style="border:0px;width:700px">
                </section>
            </section>
			<section>
				<section>
                     <h2>Image-Workflow</h2>
                     <img src="images/ImageProcessing.svg"  style="border:0px;width:800px" alt="Übersicht Nachrichtentransport">
                 </section>
				<section>
					<h3>Freischalten Build-Script</h3>
					    <pre><code class="powershell">
Set-ExecutionPolicy RemoteSigned
                    </code></pre>
					Infos <a href="https://technet.microsoft.com/de-de/library/ee176961.aspx" target="_blank"> Microsoft Technet</a>
				</section>
				<section>
                     <h3>WebApp </h3>
                     <ul>
                        <li>Anfragen zur Authentifzierung versenden</li>
                        <li>Authentifzierungsantworten empfangen und in AuthenticationRepository verarbeiten</li>
                        <li>Verarbeitungsjob mit Folgeschritten erstellen und versenden</li>
                     </ul>
                 </section>
                 <section>
                     <h3>Authorization / Uploader  </h3>
                     <ul>
                         <li>Anfragen zur Authentifzierung empfangen und Benutzerdaten gegen UserRepository prüfen</li>
                         <li>Authentifzierungsantworten mit Prüfergebnis versenden</li>
                         <li>Versandjobs an externe Anwendung empfangen und per HTTP übertragen</li>
                     </ul>
                </section>
                <section>
                    <h3>Image Prozessor / Image Persitor</h3>
                    <ul>
                        <li>Verarbeitungsjob empfangen und an Grafikverarbeitung übergeben</li>
                        <li>Folgejobs an Persitor / Uploader versenden</li>
                        <li>Grafiken für den Benutzer speichern</li>
                    </ul>
                  </section>
                  <section>
                      TBD: Info für Docker-Images / Compose

                  </section>
			</section>
            <section>
                <section> <h2>TLS RabbitMQ mit SSL / TLS</h2>
                    <img src="images/logo_rabbitmq.png" style="border:0px" alt="Logo of Rabbit MQ"/>
                </section>
                <section>
                      <h2>IoT App</h2>
                    <img src="images/IoTApp.svg" alt="IoT App" style="border:0px;width:800px">
                </section>
                <section>
                      Start Cert-Store
                     <pre>
                            <code data-trim contenteditable>$ docker run --name certstore 
    fpommerening/spartakiade2017-rabbitmq:ssl-certstore</code>
                     </pre>
                     Starten CA 
                     <pre>
                            <code data-trim contenteditable>$ docker run -it --rm --volumes-from certstore 
    fpommerening/spartakiade2017-rabbitmq:ssl-ca /bin/bash</code>
                     </pre>
                     Zertifikate erstellen
                      <pre>
                            <code data-trim contenteditable>cd /usr/local/bin/
./ca.sh MyCA
./server.sh rabbitServer strenggeheim
./client.sh rabbitClient strenggeheim</code>
                     </pre>
                </section>
                <section>
                Start RabbitMQ mit SSL
                    <pre>
                            <code data-trim contenteditable>
$ docker run -d --name rabbitssl --volumes-from certstore 
    -p 15671:15671 -p 5671:5671 
    -e RABBITMQ_SSL_CACERTFILE=/rabbitssl/ca/cacert.pem 
    -e RABBITMQ_SSL_CERTFILE=/rabbitssl/server/cert.pem 
    -e RABBITMQ_SSL_KEYFILE=/rabbitssl/server/key.pem 
    rabbitmq:3-management
                            </code>
                     </pre>
Client - Zertifikate kopieren
                      <pre>
                            <code data-trim contenteditable>
$ docker cp certstore:/rabbitssl/client/keycert.p12 .
                            </code>
                     </pre>
                </section>
                <section>
                   <h3> EasyNetQ mit SSL</h3>
                    <pre><code class="cs">
var connection = new ConnectionConfiguration();
connection.Port = 5671;
connection.UserName = "guest";
connection.Password = "guest";
connection.Product = "SSLTest;
                 </code></pre>
<pre><code class="cs">
var host1 = new HostConfiguration();
host1.Host = "localhost";
host1.Port = 5671;
host1.Ssl.Enabled = true;
host1.Ssl.ServerName = "rabbitServer";
host1.Ssl.CertPath = @"c:\Temp\keycert.p12";
host1.Ssl.CertPassphrase = "strenggeheim";
host1.Ssl.AcceptablePolicyErrors =
     SslPolicyErrors.RemoteCertificateNameMismatch | 
     SslPolicyErrors.RemoteCertificateChainErrors;
connection.Hosts = new List< HostConfiguration> { host1 };
connection.Validate();
myBus = RabbitHutch.CreateBus(connection, services => { });
                    </code></pre>
                </section>
            </section>
            <section>
                <section>
                <h2> V-HOSTS Benutzer / Password</h2>
                </section>
                <section>
                    TBD: Screenshot Management
                </section>
                <section>
                   Verbindung mit V-Host und / oder alternativem Benutzer erfolgt per Connectionstring.
                    <br />
                   <br />
                   V-Host
                   <br />
                    <pre><code class="cs">
var myBus = RabbitHutch.CreateBus(
    "host=localhost;virtualHost=myHost");
                    </code></pre>
                     <br />
                    Benutzer / Passwort
                    <br />
                         <pre><code class="cs">
var myBus = RabbitHutch.CreateBus(
    "host=localhost;username=myUser;password=myPasswort");
                    </code></pre>
                </section>
                <section>
                    TBD: Übersichtsgrafik V-Host
                </section>
            </section>
            <section>
                <section>
                    <h2>Zeitgesteuertes Queuing</h2>
                </section>
                <section>
                    TBD: EasyNetQ IScheduler
                </section>

                <section>
                    RabbitMQ Delayed Message Plugin<br/>
                    <a href="https://github.com/rabbitmq/rabbitmq-delayed-message-exchange/" target="_blank">GitHub</a>
                    <br />
                    Starten Docker-Image mit Plugin
                    <br />
                      <pre>
                            <code data-trim contenteditable>
$ docker run -d --hostname rmqDelayEx --name rmqDelayEx
    -p 5672:5672 -p 15672:15672
    fpommerening/spartakiade2017-rabbitmq:rabbitmq-delaymxmgm
                            </code>
                        </pre>
                    Die IScheduler-Implementierung DelayedExchangeScheduler wird von EasyNetQ mitgeliefert.
                    Delayed Message Plugin unterstützt kein Abbruch (Cancelling) von Nachrichten -> NotImplementedException!
                </section>
                <section>
                    TBD: Übersichtsgrafik Mongo
                </section>
            </section>
            <section>
                <h2> TBD: Verknüpfung Node.js + EasyNETQ</h2>
            </section>
            <section>
                <section>
                    <h2>Weiterführende Informationen</h2>
                </section>
                <section>
                    https://weblogs.asp.net/jeffreyabecker/Using-SSL-client-certificates-for-authentication-with-RabbitMQ
                </section>
            </section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				history: true,

				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
